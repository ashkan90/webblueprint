package engine

import (
	"context"
	"fmt"
	"maps"

	// "strings" // No longer needed directly here
	"sync"
	"time"
	"webblueprint/internal/db" // Added for SchemaAccessContext implementation

	// "webblueprint/internal/engineext" // No longer needed directly here
	"webblueprint/internal/node"
	"webblueprint/internal/types"
	"webblueprint/pkg/blueprint"
	// "webblueprint/pkg/repository" // No longer needed directly here
)

// NodeActor represents a single node in the actor model system
type NodeActor struct {
	NodeID        string
	NodeType      string
	ExecutionID   string
	node          node.Node
	bp            *blueprint.Blueprint
	mailbox       chan NodeMessage
	inputs        map[string]types.Value
	outputs       map[string]types.Value // Actor's persistent outputs (if needed)
	variables     map[string]types.Value // ActorSystem's shared variables map reference
	status        NodeStatus
	ctx           *ActorExecutionContext // Internal context for actor methods
	logger        node.Logger
	listeners     []ExecutionListener
	debugMgr      *DebugManager
	done          chan struct{}
	mutex         sync.RWMutex          // General mutex for actor state (inputs, outputs, status)
	variableMutex *sync.RWMutex         // Specific mutex for shared variables map
	properties    []types.Property      // Store node properties from the blueprint
	decoratedCtx  node.ExecutionContext // Store the potentially decorated context passed to Start
	system        *ActorSystem          // Reference to the parent actor system

	// Add hooks
	nodeExecutionHook func(ctx context.Context, executionID, nodeID, nodeType, execState string,
		inputs, outputs map[string]interface{}) error
	anyHook func(ctx context.Context, executionID, nodeID, level, message string,
		details map[string]interface{}) error

	// Loop state (only relevant for loop actors)
	loopCurrentIndex  float64
	loopMaxIterations int
	loopStartIndex    float64
	isLooping         bool
}

// NodeMessage represents a message that can be sent to a NodeActor
type NodeMessage struct {
	Type       string                 // Message type: "execute", "input", "stop", "loop_next"
	PinID      string                 // Target pin ID for input messages
	Value      types.Value            // Value for input messages or loop payload
	Response   chan NodeResponse      // Channel for the response
	FlowData   map[string]interface{} // Additional flow data
	TriggerPin string                 // Pin that triggered an execute message
}

// NodeResponse is the response to a NodeMessage
type NodeResponse struct {
	Success        bool
	Error          error
	OutputPins     map[string]types.Value // Outputs generated by this step
	FlowToActivate string                 // Explicitly signals which execution pin to follow (used by LoopNode)
	// IterationPayload types.Value // Payload is derived from OutputPins["index"] by ActorSystem now
}

// NewNodeActor creates a new actor for a node
func NewNodeActor(
	nodeID, nodeType string,
	bp *blueprint.Blueprint,
	executionID string,
	nodeInstance node.Node,
	logger node.Logger,
	listeners []ExecutionListener,
	debugMgr *DebugManager,
	sharedVariables map[string]types.Value, // Use shared variables map
	variableMutex *sync.RWMutex, // Use shared variable mutex
	system *ActorSystem, // Added system reference
	nodeExecutionHook func(ctx context.Context, executionID, nodeID, nodeType, execState string,
		inputs, outputs map[string]interface{}) error,
	anyHook func(ctx context.Context, executionID, nodeID, level, message string,
		details map[string]interface{}) error,
) *NodeActor {

	// Load node properties from blueprint
	var properties []types.Property
	if nodeConfig := bp.FindNode(nodeID); nodeConfig != nil {
		propertyLog := make(map[string]interface{})
		for _, property := range nodeConfig.Properties {
			// Attempt to set property on the node instance if method exists
			if setter, ok := nodeInstance.(interface{ SetProperty(string, interface{}) }); ok {
				setter.SetProperty(property.Name, property.Value)
			}
			properties = append(properties, types.Property{
				Name:  property.Name,
				Value: property.Value,
			})
			propertyLog["property."+property.Name] = property.Value
		}
		maps.Copy(propertyLog, map[string]interface{}{
			"nodeId":           nodeID,
			"properties.count": len(properties),
		})
		logger.Debug("Loaded node properties", propertyLog)
	}

	return &NodeActor{
		NodeID:        nodeID,
		NodeType:      nodeType,
		ExecutionID:   executionID,
		node:          nodeInstance,
		bp:            bp,
		mailbox:       make(chan NodeMessage, 1024), // Buffer for handling multiple messages
		inputs:        make(map[string]types.Value), // Actor's current inputs
		outputs:       make(map[string]types.Value), // Actor's persistent outputs (if needed)
		variables:     sharedVariables,              // Store reference to shared map
		variableMutex: variableMutex,                // Store reference to shared mutex
		status: NodeStatus{
			NodeID: nodeID,
			Status: "idle",
		},
		logger:            logger,
		listeners:         listeners,
		debugMgr:          debugMgr,
		done:              make(chan struct{}),
		properties:        properties,
		nodeExecutionHook: nodeExecutionHook,
		anyHook:           anyHook,
		system:            system, // Store system reference
	}
}

// Helper interface to check if a context wraps another
type contextWrapper interface {
	Unwrap() node.ExecutionContext
}

// Start begins processing messages from the mailbox
func (a *NodeActor) Start(ctx node.ExecutionContext) {
	if ctx == nil {
		a.logger.Error("Cannot start NodeActor with nil context", nil)
		return
	}

	// Store the potentially decorated context if provided
	a.decoratedCtx = ctx

	// Always create a specific ActorExecutionContext for internal actor use
	// Pass the shared variables and mutex from the actor itself
	// Corrected call to NewActorExecutionContext (adding back ctx based on compiler error)
	a.ctx = NewActorExecutionContext(
		ctx,             // Pass the decorated context
		a.NodeID,        // Pass NodeID
		a.NodeType,      // Pass NodeType
		a.bp.ID,         // Pass BlueprintID
		a.ExecutionID,   // Pass ExecutionID
		a.logger,        // Pass Logger
		a,               // Pass Actor reference
		a.variables,     // Pass shared variables map
		a.variableMutex, // Pass shared variable mutex
	)

	// Start processing messages
	go a.processMessages()
}

// Stop gracefully stops the actor
func (a *NodeActor) Stop() {
	close(a.done)
}

// Send sends a message to the actor and waits for a response
func (a *NodeActor) Send(msg NodeMessage) NodeResponse {
	// Create a response channel if not provided
	if msg.Response == nil {
		responseChan := make(chan NodeResponse, 1)
		msg.Response = responseChan
	}

	select {
	case a.mailbox <- msg:
		// Message sent, wait for response
		select {
		case response, ok := <-msg.Response:
			if !ok {
				// Channel was closed
				return NodeResponse{
					Success: false,
					Error:   fmt.Errorf("response channel closed for node %s", a.NodeID),
				}
			}
			return response
		case <-time.After(10 * time.Second): // TODO: Make timeout configurable
			// Timeout waiting for response
			return NodeResponse{
				Success: false,
				Error:   fmt.Errorf("timeout waiting for node response from %s", a.NodeID),
			}
		}
	case <-time.After(2 * time.Second): // TODO: Make timeout configurable
		// Timeout sending message
		return NodeResponse{
			Success: false,
			Error:   fmt.Errorf("mailbox full for node %s, node may be busy or deadlocked", a.NodeID),
		}
	}
}

// SendAsync sends a message to the actor without waiting for a response
func (a *NodeActor) SendAsync(msg NodeMessage) bool {
	select {
	case a.mailbox <- msg:
		// Message sent
		return true
	case <-time.After(1 * time.Second): // TODO: Make timeout configurable
		// Mailbox full, log an error
		a.logger.Error("Failed to send message to node actor, mailbox full", map[string]interface{}{
			"nodeId":  a.NodeID,
			"msgType": msg.Type,
		})
		return false
	}
}

// GetProperty retrieves a property value by name
func (a *NodeActor) GetProperty(name string) (interface{}, bool) {
	// No mutex needed if properties are immutable after creation
	for _, prop := range a.properties {
		if prop.Name == name {
			return prop.Value, true
		}
	}
	return nil, false
}

// InitializeLoop sets the initial state for a loop actor
func (a *NodeActor) InitializeLoop(startIndex float64, maxIterations int) {
	a.mutex.Lock()
	defer a.mutex.Unlock()
	a.loopStartIndex = startIndex
	a.loopCurrentIndex = startIndex
	a.loopMaxIterations = maxIterations
	a.isLooping = true
}

// processMessages handles messages from the mailbox
func (a *NodeActor) processMessages() {
	for {
		select {
		case <-a.done:
			// Actor is being stopped
			return
		case msg, ok := <-a.mailbox:
			if !ok {
				// Mailbox was closed
				return
			}
			// Process the message
			response := a.handleMessage(msg)

			// Send the response if a response channel was provided
			if msg.Response != nil {
				select {
				case msg.Response <- response:
				default:
					// Response channel is full or closed
					a.logger.Warn("Could not send response, channel may be full or closed", map[string]interface{}{
						"nodeId":  a.NodeID,
						"msgType": msg.Type,
					})
				}
				// Close the response channel after sending? Depends on usage pattern.
				// close(msg.Response)
			}
		}
	}
}

// handleMessage processes a single message
func (a *NodeActor) handleMessage(msg NodeMessage) NodeResponse {
	switch msg.Type {
	case "execute":
		return a.handleExecuteMessage(msg)
	case "input":
		return a.handleInputMessage(msg)
	case "stop":
		return a.handleStopMessage(msg)
	case "loop_next":
		res := a.handleLoopNextMessage(msg)

		a.system.followConnections(a, res)

		return res
	default:
		return NodeResponse{
			Success: false,
			Error:   fmt.Errorf("unknown message type: %s", msg.Type),
		}
	}
}

// handleExecuteMessage handles an execute message
func (a *NodeActor) handleExecuteMessage(msg NodeMessage) NodeResponse {
	// Update node status
	a.mutex.Lock()
	a.status.Status = "executing"
	a.status.StartTime = time.Now()
	a.mutex.Unlock()

	// Mark node as executing
	a.emitNodeStartedEvent()

	// Record node execution start with inputs
	if a.nodeExecutionHook != nil {
		inputMap := make(map[string]interface{})
		a.mutex.RLock()
		for pinID, value := range a.inputs {
			inputMap[pinID] = value.RawValue
		}
		a.mutex.RUnlock()
		errHook := a.nodeExecutionHook(context.Background(), a.ExecutionID, a.NodeID, a.NodeType, "executing", inputMap, nil)
		if errHook != nil {
			a.logger.Debug("Error in node execution hook (start)", map[string]interface{}{"nodeId": a.NodeID, "error": errHook.Error()})
		}
	}

	// Prepare context for execution
	// Use the internal actor context 'a.ctx' which has shared variable access
	execCtx := a.ctx
	// Set the pin that triggered this execution, if provided
	if msg.TriggerPin != "" {
		execCtx.activePin = msg.TriggerPin
	} else {
		execCtx.activePin = "exec" // Default if not specified
	}

	// Check if this execution was triggered by a loop with an index payload
	if msg.Value.Type == types.PinTypes.Object {
		if payload, ok := msg.Value.RawValue.(map[string]interface{}); ok {
			if indexVal, exists := payload["_loop_index"]; exists {
				// Inject the loop index as a variable into the context
				loopIndexVarName := "_current_loop_index"
				execCtx.SetVariable(loopIndexVarName, types.NewValue(types.PinTypes.Number, indexVal))
				a.logger.Debug("Injected loop index into context variable", map[string]interface{}{"varName": loopIndexVarName, "index": indexVal})
			}
		}
	}

	// Execute the node using the prepared context
	err := a.node.Execute(execCtx) // Pass the ActorExecutionContext

	// Retrieve outputs generated during this execution step from the context
	// Use the specific getter that accesses the context's local outputs
	outputs := execCtx.GetAllOutputs()

	// Update actor's persistent outputs if necessary (optional, depends on design)
	a.mutex.Lock()
	for k, v := range a.outputs {
		outputs[k] = v
	}
	a.mutex.Unlock()

	// Record node execution completion with outputs
	if a.nodeExecutionHook != nil {
		outputMap := make(map[string]interface{})
		for pinID, value := range outputs {
			outputMap[pinID] = value.RawValue
		}
		errHook := a.nodeExecutionHook(context.Background(), a.ExecutionID, a.NodeID, a.NodeType, "completed", nil, outputMap)
		if errHook != nil {
			a.logger.Debug("Error in node execution hook (complete)", map[string]interface{}{"nodeId": a.NodeID, "error": errHook.Error()})
		}
	}

	// Store outputs in debug manager
	if a.debugMgr != nil {
		for pinID, value := range outputs {
			a.debugMgr.StoreNodeOutputValue(a.ExecutionID, a.NodeID, pinID, value.RawValue)
		}
	}

	// Update node status based on execution result
	a.mutex.Lock()
	a.status.EndTime = time.Now()
	if err != nil {
		a.status.Status = "error"
		a.status.Error = err
	} else {
		a.status.Status = "completed"
	}
	a.mutex.Unlock()

	// Mark node as completed or error
	if err != nil {
		a.emitNodeErrorEvent(err)
		return NodeResponse{
			Success:    false,
			Error:      err,
			OutputPins: outputs, // Return outputs even on error
		}
	}

	a.emitNodeCompletedEvent()
	return NodeResponse{
		Success:    true,
		OutputPins: outputs, // Return outputs generated by this step
	}
}

// handleInputMessage handles an input message
func (a *NodeActor) handleInputMessage(msg NodeMessage) NodeResponse {
	if msg.PinID == "" {
		a.logger.Error("Input message missing pin ID", nil)
		return NodeResponse{
			Success: false,
			Error:   fmt.Errorf("input message missing pin ID"),
		}
	}

	if msg.Value.Type == nil {
		a.logger.Warn("Received nil type for pin", map[string]interface{}{
			"pinId": msg.PinID,
		})
		// Assign a default type? Or handle potential nil dereference later?
		// For now, let's allow it but log.
	}

	// Store the input value in the actor's input map
	a.mutex.Lock()
	a.inputs[msg.PinID] = msg.Value
	a.mutex.Unlock()

	// Also store input in the internal execution context 'a.ctx'
	// This might be redundant if GetInputValue reads directly from actor.inputs
	if a.ctx != nil {
		a.ctx.SetInput(msg.PinID, msg.Value)
	}

	// Log the received input for debugging
	a.logger.Debug("Received input value", map[string]interface{}{
		"pinId": msg.PinID,
		//"valueType": fmt.Sprintf("%T", msg.Value.RawValue),
		//"value":     msg.Value.RawValue,
	})

	// Return success
	return NodeResponse{
		Success: true,
	}
}

// handleLoopNextMessage handles the logic for the next loop iteration
func (a *NodeActor) handleLoopNextMessage(msg NodeMessage) NodeResponse {
	a.mutex.Lock() // Lock for accessing loop state

	// Check if we should continue looping
	if !a.isLooping || int(a.loopCurrentIndex-a.loopStartIndex) >= a.loopMaxIterations {
		// Loop finished or was stopped
		a.isLooping = false
		finalIndex := a.loopCurrentIndex - 1 // Index of the last iteration
		if finalIndex < a.loopStartIndex {
			finalIndex = a.loopStartIndex // Handle case where loop didn't run
		}
		a.mutex.Unlock() // Unlock before triggering flow

		a.logger.Info("Loop finished or stopped", map[string]interface{}{
			"currentIndex":  finalIndex,
			"maxIterations": a.loopMaxIterations,
		})

		// Signal "completed" flow activation via NodeResponse
		return NodeResponse{
			Success: true,
			OutputPins: map[string]types.Value{
				"index": types.NewValue(types.PinTypes.Number, finalIndex),
			},
			FlowToActivate: "completed",
		}
	}

	// Prepare for the current iteration
	currentIndex := a.loopCurrentIndex
	iterationNumber := int(currentIndex - a.loopStartIndex)

	// Set the index output for this iteration
	indexOutputValue := types.NewValue(types.PinTypes.Number, currentIndex)
	a.outputs["index"] = indexOutputValue // Update actor's persistent output state

	// Payload creation moved to ActorSystem.followConnections
	// loopIterationPayload := map[string]interface{}{
	// 	"_loop_index": currentIndex,
	// }
	// Removed stray closing brace
	// We'll pass this payload via NodeResponse, ActorSystem will handle injection

	// Increment index for the *next* potential iteration *before* unlocking
	a.loopCurrentIndex++

	a.mutex.Unlock() // Unlock after accessing/modifying loop state

	a.logger.Info(fmt.Sprintf("handleLoop Loop iteration %d", iterationNumber), map[string]interface{}{
		"index": currentIndex,
	})

	// Signal "loop" flow activation via NodeResponse
	return NodeResponse{
		Success:        true,
		OutputPins:     map[string]types.Value{"index": indexOutputValue}, // Provide current index output
		FlowToActivate: "loop",                                            // Explicitly signal loop body
	}
}

// handleStopMessage handles a stop message
func (a *NodeActor) handleStopMessage(msg NodeMessage) NodeResponse {
	// Stop the actor
	a.Stop()

	// Return success
	return NodeResponse{
		Success: true,
	}
}

// emitNodeStartedEvent emits an event when the node starts executing
func (a *NodeActor) emitNodeStartedEvent() {
	for _, listener := range a.listeners {
		listener.OnExecutionEvent(ExecutionEvent{
			Type:      EventNodeStarted,
			Timestamp: time.Now(),
			NodeID:    a.NodeID,
			Data: map[string]interface{}{
				"nodeType": a.NodeType,
				"status":   "executing",
			},
		})
	}

	// Use the anyHook if provided
	if a.anyHook != nil {
		a.anyHook(context.Background(), a.ExecutionID, a.NodeID, "info", string(EventNodeStarted), map[string]interface{}{
			"nodeType":  a.NodeType,
			"timestamp": time.Now(),
		})
	}
}

// emitNodeCompletedEvent emits an event when the node completes execution
func (a *NodeActor) emitNodeCompletedEvent() {
	for _, listener := range a.listeners {
		listener.OnExecutionEvent(ExecutionEvent{
			Type:      EventNodeCompleted,
			Timestamp: time.Now(),
			NodeID:    a.NodeID,
			Data: map[string]interface{}{
				"nodeType": a.NodeType,
				"status":   "completed",
			},
		})
	}

	// Use the anyHook if provided
	if a.anyHook != nil {
		a.anyHook(context.Background(), a.ExecutionID, a.NodeID, "info", string(EventNodeCompleted), map[string]interface{}{
			"nodeType":  a.NodeType,
			"timestamp": time.Now(),
		})
	}
}

// emitNodeErrorEvent emits an event when the node encounters an error
func (a *NodeActor) emitNodeErrorEvent(err error) {
	for _, listener := range a.listeners {
		listener.OnExecutionEvent(ExecutionEvent{
			Type:      EventNodeError,
			Timestamp: time.Now(),
			NodeID:    a.NodeID,
			Data: map[string]interface{}{
				"nodeType": a.NodeType,
				"status":   "error",
				"error":    err.Error(),
			},
		})
	}

	// Use the anyHook if provided
	if a.anyHook != nil {
		a.anyHook(context.Background(), a.ExecutionID, a.NodeID, "error", string(EventNodeError), map[string]interface{}{
			"error": err.Error(),
		})
	}
}

// emitValueProducedEvent emits an event when a value is produced on an output pin
func (a *NodeActor) emitValueProducedEvent(pinID string, value interface{}) {
	for _, listener := range a.listeners {
		listener.OnExecutionEvent(ExecutionEvent{
			Type:      EventValueProduced,
			Timestamp: time.Now(),
			NodeID:    a.NodeID,
			Data: map[string]interface{}{
				"pinId": pinID,
				"value": value,
			},
		})
	}

	// Use the anyHook if provided
	if a.anyHook != nil {
		a.anyHook(context.Background(), a.ExecutionID, a.NodeID, "debug", string(EventValueProduced), map[string]interface{}{
			"pinId": pinID,
			"value": value,
		})
	}
}

// SetOutput sets an output value (on the actor's persistent state if needed)
func (a *NodeActor) SetOutput(pinID string, value types.Value) {
	a.mutex.Lock()
	a.outputs[pinID] = value
	a.mutex.Unlock()

	// Store in debug manager
	if a.debugMgr != nil {
		a.debugMgr.StoreNodeOutputValue(a.ExecutionID, a.NodeID, pinID, value.RawValue)
	}

	// Emit value produced event
	a.emitValueProducedEvent(pinID, value.RawValue)
}

// GetOutput gets an output value (from the actor's persistent state)
func (a *NodeActor) GetOutput(pinID string) (types.Value, bool) {
	a.mutex.RLock()
	defer a.mutex.RUnlock()

	value, exists := a.outputs[pinID]
	return value, exists
}

// GetStatus returns the current status of the node
func (a *NodeActor) GetStatus() NodeStatus {
	a.mutex.RLock()
	defer a.mutex.RUnlock()

	return a.status
}

// ActorExecutionContext is the execution context for a node actor
type ActorExecutionContext struct {
	baseCtx     node.ExecutionContext
	nodeID      string
	nodeType    string
	blueprintID string
	executionID string
	inputs      map[string]types.Value
	// variables       map[string]types.Value // Removed direct reference
	sharedVariables    map[string]types.Value // Reference to ActorSystem's variables
	sharedVarMutex     *sync.RWMutex          // Mutex for shared variables
	outputs            map[string]types.Value // Local outputs for this node's execution
	debugData          map[string]interface{}
	logger             node.Logger
	actor              *NodeActor
	activatedFlows     []string        // Store activated flows locally
	activePin          string          // The pin that triggered execution
	activePins         map[string]bool // Tracks which input execution pin was activated
	localOutputsMutex  sync.Mutex      // Mutex specifically for local outputs map
	activatedFlowMutex sync.Mutex      // Mutex for activated flows
}

// NewActorExecutionContext creates a new execution context for a node actor
func NewActorExecutionContext(
	baseCtx node.ExecutionContext,
	nodeID string,
	nodeType string,
	blueprintID string,
	executionID string,
	logger node.Logger,
	actor *NodeActor,
	sharedVars map[string]types.Value, // Pass shared map
	sharedVarMutex *sync.RWMutex, // Pass shared mutex
) *ActorExecutionContext {
	// Copy the actor's inputs to initialize the context
	inputs := make(map[string]types.Value)
	actor.mutex.RLock() // Lock actor for reading inputs
	for k, v := range actor.inputs {
		inputs[k] = v
	}
	actor.mutex.RUnlock()

	return &ActorExecutionContext{
		baseCtx:         baseCtx,
		nodeID:          nodeID,
		nodeType:        nodeType,
		blueprintID:     blueprintID,
		executionID:     executionID,
		inputs:          inputs,
		sharedVariables: sharedVars,                   // Store reference to shared map
		sharedVarMutex:  sharedVarMutex,               // Store reference to shared mutex
		outputs:         make(map[string]types.Value), // Initialize local outputs
		debugData:       make(map[string]interface{}),
		logger:          logger,
		actor:           actor,
		activatedFlows:  make([]string, 0),     // Initialize activated flows
		activePins:      make(map[string]bool), // Initialize active pins map
	}
}

// SetInput sets an input value
func (ctx *ActorExecutionContext) SetInput(pinID string, value types.Value) {
	// Assuming inputs are set before execution starts and don't need mutex during execution
	ctx.inputs[pinID] = value
}

// GetActivatedOutputFlows returns the list of activated output flows
func (ctx *ActorExecutionContext) GetActivatedOutputFlows() []string {
	ctx.activatedFlowMutex.Lock()         // Use specific mutex
	defer ctx.activatedFlowMutex.Unlock() // Use specific mutex
	// Return a copy
	flows := make([]string, len(ctx.activatedFlows))
	copy(flows, ctx.activatedFlows)
	return flows
}

func (ctx *ActorExecutionContext) GetBlueprint() *blueprint.Blueprint {
	// No mutex needed if actor.bp is immutable after creation
	return ctx.actor.bp
}

// Implementation of node.ExecutionContext interface for ActorExecutionContext

// IsInputPinActive checks if the input pin triggered execution
func (ctx *ActorExecutionContext) IsInputPinActive(pinID string) bool {
	// If a specific active pin is set, check it
	if ctx.activePin != "" {
		return ctx.activePin == pinID
	}
	// Check the map if multiple pins could be active (less common for execute)
	if active, exists := ctx.activePins[pinID]; exists && active {
		return true
	}
	// Default fallback for standard 'exec' if nothing else is active
	if len(ctx.activePins) == 0 && ctx.activePin == "" && pinID == "exec" {
		return true
	}
	return false
}

// GetInputValue retrieves an input value by pin ID
func (ctx *ActorExecutionContext) GetInputValue(pinID string) (types.Value, bool) {
	// Inputs are generally set before execution, potentially no mutex needed here
	// depending on actor lifecycle and message handling guarantees.
	// Add mutex if inputs can be modified concurrently during execution.
	value, exists := ctx.inputs[pinID]

	if !exists {
		return ctx.baseCtx.GetInputValue(pinID)
	}

	return value, exists
}

// SetOutputValue sets a local output value for this execution step
func (ctx *ActorExecutionContext) SetOutputValue(pinID string, value types.Value) {
	ctx.baseCtx.SetOutputValue(pinID, value)

	ctx.localOutputsMutex.Lock()         // Use specific mutex
	defer ctx.localOutputsMutex.Unlock() // Use specific mutex
	if ctx.outputs == nil {
		ctx.outputs = make(map[string]types.Value)
	}
	ctx.outputs[pinID] = value

	// Trigger hook if available (using actor's hooks)
	if ctx.actor != nil && ctx.actor.anyHook != nil { // Use anyHook for general value events
		ctx.actor.anyHook(context.Background(), ctx.executionID, ctx.nodeID, "debug", string(EventValueProduced), map[string]interface{}{
			"pinId": pinID,
			"value": value.RawValue,
		})
	}
}

// ActivateOutputFlow marks an output execution flow as activated
func (ctx *ActorExecutionContext) ActivateOutputFlow(pinID string) error {
	ctx.activatedFlowMutex.Lock()         // Use specific mutex
	defer ctx.activatedFlowMutex.Unlock() // Use specific mutex
	found := false
	for _, p := range ctx.activatedFlows {
		if p == pinID {
			found = true
			break
		}
	}
	if !found {
		ctx.activatedFlows = append(ctx.activatedFlows, pinID)
	}
	// Actual triggering happens in ActorSystem.followConnections
	return nil
}

// ExecuteConnectedNodes is complex in actor model, delegate to ActivateOutputFlow
func (ctx *ActorExecutionContext) ExecuteConnectedNodes(pinID string) error {
	return ctx.ActivateOutputFlow(pinID)
}

// GetVariable retrieves a variable by name from the shared map
func (ctx *ActorExecutionContext) GetVariable(name string) (types.Value, bool) {
	ctx.sharedVarMutex.RLock()         // Lock shared mutex
	defer ctx.sharedVarMutex.RUnlock() // Unlock shared mutex
	value, exists := ctx.sharedVariables[name]
	return value, exists
}

// SetVariable sets a variable by name in the shared map
func (ctx *ActorExecutionContext) SetVariable(name string, value types.Value) {
	ctx.sharedVarMutex.Lock()         // Lock shared mutex
	defer ctx.sharedVarMutex.Unlock() // Unlock shared mutex
	ctx.sharedVariables[name] = value
	ctx.logger.Debug("Set shared variable", map[string]interface{}{"name": name, "value": value.RawValue})
}

// Logger returns the execution logger
func (ctx *ActorExecutionContext) Logger() node.Logger {
	return ctx.logger
}

// RecordDebugInfo stores debug information
func (ctx *ActorExecutionContext) RecordDebugInfo(info types.DebugInfo) {
	key := fmt.Sprintf("debug_%d", time.Now().UnixNano())
	// No mutex needed if debugData is only accessed by this actor's thread
	if ctx.debugData == nil { // Defensive init
		ctx.debugData = make(map[string]interface{})
	}
	ctx.debugData[key] = info

	// Store in debug manager if available (no mutex needed for this part)
	if ctx.actor != nil && ctx.actor.debugMgr != nil {
		ctx.actor.debugMgr.StoreNodeDebugData(ctx.executionID, ctx.nodeID, map[string]interface{}{
			key: info,
		})
	}
}

// GetDebugData returns all debug data collected in this context
func (ctx *ActorExecutionContext) GetDebugData() map[string]interface{} {
	// No mutex needed if debugData is only accessed by this actor's thread
	dataCopy := make(map[string]interface{}, len(ctx.debugData))
	for k, v := range ctx.debugData {
		dataCopy[k] = v
	}
	return dataCopy
}

// --- ExtendedExecutionContext Methods ---

// GetOutputValue retrieves an output value by pin ID
func (ctx *ActorExecutionContext) GetOutputValue(pinID string) (types.Value, bool) {
	ctx.localOutputsMutex.Lock()         // Use specific mutex
	defer ctx.localOutputsMutex.Unlock() // Use specific mutex
	value, exists := ctx.outputs[pinID]
	return value, exists
}

// GetAllOutputs returns all outputs set in this context
func (ctx *ActorExecutionContext) GetAllOutputs() map[string]types.Value {
	ctx.localOutputsMutex.Lock()         // Use specific mutex
	defer ctx.localOutputsMutex.Unlock() // Use specific mutex
	outputsCopy := make(map[string]types.Value)
	// Ensure outputs map is initialized
	if ctx.outputs == nil {
		return outputsCopy // Return empty map if nil
	}
	for k, v := range ctx.outputs {
		outputsCopy[k] = v
	}

	return outputsCopy
}

// --- LoopContext Interface (Placeholder Implementation) ---
// These methods satisfy the interface but rely on delegation or are placeholders,
// as ActorExecutionContext doesn't inherently manage loop iterations itself.

func (ctx *ActorExecutionContext) CreateLoopContext(loopVarName string, maxIterations int, startIndex float64) (node.LoopContext, bool) {
	// Actor context might not directly support creating nested loop contexts this way.
	// Delegate to the underlying decorated context if possible.
	if baseCtx, ok := ctx.actor.decoratedCtx.(interface {
		CreateLoopContext(string, int, float64) (node.LoopContext, bool)
	}); ok {
		return baseCtx.CreateLoopContext(loopVarName, maxIterations, startIndex)
	}
	// Indicate that loop context creation is not supported directly by this context type
	return nil, false
}

func (ctx *ActorExecutionContext) SetCurrentIndex(index float64) { /* Placeholder */ }
func (ctx *ActorExecutionContext) CurrentIndex() float64         { return 0 /* Placeholder */ }
func (ctx *ActorExecutionContext) MaxIterations() int            { return 0 /* Placeholder */ }
func (ctx *ActorExecutionContext) StartIndex() float64           { return 0 /* Placeholder */ }
func (ctx *ActorExecutionContext) IterationsDone() int           { return 0 /* Placeholder */ }
func (ctx *ActorExecutionContext) IncrementIterationsDone()      { /* Placeholder */ }
func (ctx *ActorExecutionContext) BodyCompletedSignal() <-chan bool {
	return nil /* Placeholder - Loop coordination managed elsewhere */
}
func (ctx *ActorExecutionContext) ExecutionDoneSignal() <-chan bool {
	return nil /* Placeholder */
}
func (ctx *ActorExecutionContext) SignalIterationComplete() { /* Placeholder */ }

// --- SchemaAccessContext Interface ---

// GetSchemaComponentStore retrieves the store via the actor's context
func (ctx *ActorExecutionContext) GetSchemaComponentStore() db.SchemaComponentStore {
	// Delegate to the underlying decorated context
	if schemaCtx, ok := ctx.actor.decoratedCtx.(node.SchemaAccessContext); ok {
		return schemaCtx.GetSchemaComponentStore()
	}
	// Log error if the underlying context doesn't support schema access
	ctx.logger.Error("Underlying context does not support SchemaAccessContext", nil)
	return nil
}

// Add other necessary methods from node.ExecutionContext if not covered by embedding or delegation...

func (ctx *ActorExecutionContext) GetProperty(name string) (interface{}, bool) {
	return ctx.actor.GetProperty(name)
}

// GetNodeID returns the ID of the executing node
func (ctx *ActorExecutionContext) GetNodeID() string {
	return ctx.nodeID
}

// GetNodeType returns the type of the executing node
func (ctx *ActorExecutionContext) GetNodeType() string {
	return ctx.nodeType
}

// GetBlueprintID returns the ID of the executing blueprint
func (ctx *ActorExecutionContext) GetBlueprintID() string {
	return ctx.blueprintID
}

// GetExecutionID returns the current execution ID
func (ctx *ActorExecutionContext) GetExecutionID() string {
	return ctx.executionID
}

// SaveData is required by node.ExecutionContext
func (ctx *ActorExecutionContext) SaveData(key string, value interface{}) {
	// Actor context doesn't directly manage the underlying context.Context's values
	// This might need delegation if SaveData is essential for actors.
	// For now, it's a no-op or could log a warning.
	ctx.logger.Warn("SaveData called on ActorExecutionContext, which is not directly supported", map[string]interface{}{"key": key})
}

// GetActor returns the underlying NodeActor (needed for loop node)
func (ctx *ActorExecutionContext) GetActor() *NodeActor {
	return ctx.actor
}
